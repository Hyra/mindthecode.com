<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="alternative" href="/atom.xml" title="Mindthecode" type="application/atom+xml"><link rel="icon" href="/favicon.png"><meta name="author" content="Stef van den Ham @stefvdham"><meta property="og:type" content="article"><meta property="og:image" content="http://mindthecode.com/images/og_image.png"><meta property="og:site_name" content="Mindthecode"><meta name="twitter:creator" content="@stefvdham"><meta name="twitter:card" content="summary"><meta name="twitter:image:" content="http://mindthecode.com/images/og_image.png"><meta name="keywords" content="html, javascript, code, hacking, tutorial, tutorials, web, css"><link rel="author" href="https://plus.google.com/102230925443628784177?rel=author"><link rel="canonical" href="http://mindthecode.com"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><title>Setting up Laravel with Docker Compose - Mindthecode</title><meta property="og:title" content="Setting up Laravel with Docker Compose"><meta property="og:url" content="http://mindthecode.com/setting-up-laravel-with-docker-compose/"><meta property="og:description" content="Maintaining a local server for your projects can become cumbersome and can cause conflicts with your co-workers. Streamlining this with Docker makes sure everyone is in on the same page."><meta name="twitter:title" content="Setting up Laravel with Docker Compose"><meta name="twitter:description" content="Maintaining a local server for your projects can become cumbersome and can cause conflicts with your co-workers. Streamlining this with Docker makes sure everyone is in on the same page."><meta name="description" content="Maintaining a local server for your projects can become cumbersome and can cause conflicts with your co-workers. Streamlining this with Docker makes sure everyone is in on the same page."><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><header><a href="/" class="logo"><img src="http://mindthecode.com/logo.png" height="30" class="floating"></a><nav><ul><li><a href="/">Blog</a></li><li><a href="/about">About</a></li><li><a href="/atom.xml">RSS</a></li></ul></nav></header><main><article class="post"><header><h1><span>Setting up Laravel with Docker Compose</span></h1><h5><span>Streamlined local development</span></h5><time datetime="2016-11-27T23:00:00.000Z" class="post__time">Nov 28 2016</time></header><hr/><p>When you work on multiple projects and run these locally through, for example, Apache this means you have to maintain and tweak your local server environment all the time. Additionally, when you work on that same project with multiple people, chances are your co-workers have a slightly different setup. These slight changes in set-up can be harmless, but more times than not, cause for developer headache or unwanted code-alterations to make it work.</p>
<h2 id="Enter-Docker"><a href="#Enter-Docker" class="headerlink" title="Enter Docker"></a>Enter Docker</h2><p>Undoubtedly you have heard of <a href="https://www.docker.com/" target="_blank" rel="external">Docker</a> and maybe you even played around with it. If you haven’t, Docker describes itself as:</p>
<blockquote>
<p>Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries – anything you can install on a server. This guarantees that it will always run the same, regardless of the environment it is running in.</p>
</blockquote>
<p>Basically, Docker allows you to split up your application in different blocks called <code>containers</code> which run the same regardless of where you run them. Every container has a job and does that job by itself. Think NPM for devops.</p>
<!-- Rectangle Ad -->
<p><center><br><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-0534492338431642" data-ad-slot="3199566305"></ins><br></center></p>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>This means that every developer can run the project in exactly the same way without having to worry about their local setup and settings. Awesome.</p>
<h2 id="Add-Docker-Compose"><a href="#Add-Docker-Compose" class="headerlink" title="Add Docker-Compose"></a>Add Docker-Compose</h2><p>Running isolated containers is awesome, but sometimes you need containers to talk to each other. For instance, you have a container for your MySQL database, and one for your PHP application. The latter will want to read and write to the database running in a different container. This is where <a href="https://docs.docker.com/compose/" target="_blank" rel="external">Docker Compose</a> comes in:</p>
<blockquote>
<p>Compose is a tool for defining and running multi-container Docker applications</p>
</blockquote>
<p>Basically it allows you to orchestrate your containers in a way containers can depend on each other and the ability of them to talk to each other.</p>
<h2 id="Let’s-build-something"><a href="#Let’s-build-something" class="headerlink" title="Let’s build something"></a>Let’s build something</h2><p>So enough introductionary information, let’s put this to practice! As an example we’ll get a Laravel application up through Docker-Compose.</p>
<p>What will we be needing to make this work?</p>
<ul>
<li>A webserver to serve our application</li>
<li>PHP &gt;= 5.6.5</li>
<li>Various PHP modules, such as:<ul>
<li>OpenSSL PHP Extension</li>
<li>PDO PHP Extension</li>
<li>Mbstring PHP Extension</li>
<li>Tokenizer PHP Extension</li>
<li>XML PHP Extension</li>
</ul>
</li>
<li>A database</li>
</ul>
<p>Let’s start with number one, a basic webserver. In order to create containers through Docker Compose we need to create a new file in our root directory called <code>docker-compose.yml</code>.</p>
<h2 id="Webserver-container"><a href="#Webserver-container" class="headerlink" title="Webserver container"></a>Webserver container</h2><p>Inside this file let’s first add the necessary boilerplate:</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span>
  <span class="token comment" spellcheck="true"># We will use the latest docker-compose variant</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token comment" spellcheck="true"># Here we will define our containers</span>
</code></pre>
<p>Now we’re ready to add our first container. Let’s add a container called <code>webserver</code> to our services:</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/apache:latest'</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'80:80'</span>
</code></pre>
<p>Now, if you run <code>docker-compose up</code> from the command line it will pull in the <code>bitnami/apache</code> image and spin up our webserver container. We use <code>bitnami/apache</code> as this is a well maintained open source image which gives us sane defaults out of the box. We can also create our own images and use them inside docker-compose but I’ll write about that later.</p>
<p>With the container running, you can navigate to <code>http://localhost</code> and you should see your typical <code>It works!</code> message. Awesome, so we have a webserver running without having to run or configure anything locally besides docker.</p>
<h2 id="Mapping-our-filesystem"><a href="#Mapping-our-filesystem" class="headerlink" title="Mapping our filesystem"></a>Mapping our filesystem</h2><p>Next up we should make sure our new webserver knows where to serve our files from. Let’s create a directory <code>htdocs</code> and add a file <code>index.php</code> in there to display the PHP information:</p>
<pre class=" language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span> <span class="token keyword">echo</span> <span class="token function">phpinfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token delimiter">?></span>
</code></pre>
<p>Now we have to tell our container about our files. Docker Compose has an option <code>volumes</code> to map a local folder or file to one in the container. Let’s use that to tell our webserver container about the <code>htdocs</code> folder.</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> <span class="token string">'bitnami/apache:latest'</span>
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'80:80'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./htdocs<span class="token punctuation">:</span>/app <span class="token comment" spellcheck="true"># Map htdocs folder to app</span>
</code></pre>
<p>In the above statement we’ve mapped our local <code>htdocs</code> folder to the folder <code>app</code> in the container. Since we use <a href="https://github.com/bitnami/bitnami-docker-apache" target="_blank" rel="external">Bitnami/Apache</a> we know the container uses <code>/app</code> as the apache root folder, so by mapping our htdocs to this, our htdocs folder becomes the root.</p>
<p>Stop the docker-compose (<code>ctrl-c</code> on mac or unix) process and rerun <code>docker-compose up</code>. When everything is up again you can now visit <code>http://localhost/index.php</code> and we will see our page!</p>
<p>But wait, it’s just showing us the PHP as text without being interpreted.</p>
<p>Time to set up PHP support</p>
<h2 id="Add-PHP-to-the-containers"><a href="#Add-PHP-to-the-containers" class="headerlink" title="Add PHP to the containers"></a>Add PHP to the containers</h2><p>Now, we have two options here. We can either add an apache configuration file with PHP instructions and add this to our image to override the server settings the same we as we used volumes to map the htdocs folder, or we can say goodbye to our image and create our own Docker image. For the purpose of this walkthrough I think the latter is more beneficial, but just be aware you could do this with the forementioned route as well.</p>
<p>Right, so when we add an <code>image</code> inside our <code>docker-compose.yml</code> we’re refering to pre-fabbed Docker Containers. We can make these ourselves as well, and in essence, that’s all an image is, a set of instructions how the container should behave.</p>
<p>Let’s create a new file called <code>Dockerfile</code> and put it in the root directory alongside `docker-compose.yml’</p>
<pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">FROM ubuntu</span><span class="token punctuation">:</span>latest

RUN locale-gen en_US.UTF-8 \
  &amp;&amp; <span class="token keyword">export</span> LANG<span class="token operator">=</span>en_US.UTF-8 \
  &amp;&amp; apt-get update \
  &amp;&amp; apt-get -y install apache2

ENV APACHE_RUN_USER www-data
ENV APACHE_RUN_GROUP www-data
ENV APACHE_LOG_DIR /var/log/apache2
ENV APACHE_PID_FILE /var/run/apache2.pid
ENV APACHE_RUN_DIR /var/run/apache2
ENV APACHE_LOCK_DIR /var/lock/apache2
RUN ln -sf /dev/stdout /var/log/apache2/access.log &amp;&amp; \
    ln -sf /dev/stderr /var/log/apache2/error.log
RUN mkdir -p <span class="token variable">$APACHE_RUN_DIR</span> <span class="token variable">$APACHE_LOCK_DIR</span> <span class="token variable">$APACHE_LOG_DIR</span>

VOLUME [ <span class="token string">"/var/www/html"</span> ]
WORKDIR /var/www/html

EXPOSE 80

ENTRYPOINT [ <span class="token string">"/usr/sbin/apache2"</span> ]
CMD [<span class="token string">"-D"</span>, <span class="token string">"FOREGROUND"</span>]
</code></pre>
<p>In the above we first pull in the latest Ubuntu image. Next, we <code>RUN</code> a few commands. First we update the system so it can locate packages, next we install <code>apache2</code>. After that we set some Environmental variables for apache. Then we tell the Docker container about the volumes we want to use, expose port 80 and eventually we run apache2 so it can serve files.</p>
<p>Now we need to alter <code>docker-compose.yml</code> so it knows to use our own <code>Dockerfile</code>:</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'80:80'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./htdocs<span class="token punctuation">:</span>/var/www/html
</code></pre>
<p>Notice we changed the volume to map to <code>/var/www/html</code> as that’s the default location for our container.</p>
<p>Pfew! Let’s see where we are at. In the terminal run <code>docker-compose build</code> followed by <code>docker-compose up</code> to spin things up. We need to run <code>build</code> because we’re not using an image anymore but our own Dockerfile which needs to be built first. Whenever you make a change it’s a good habbit to first run <code>docker-compose down &amp;&amp; docker-compose build</code> to ensure your changes are propogated.</p>
<p>If all went well we should be able to open the browser at <code>http://localhost</code>. But wait, we still don’t see PHP being parsed, it’s still showing text.</p>
<p>Fear not, with the above rework to use a Dockerfile it’s easy to add PHP support by updating the <code>Dockerfile</code></p>
<h2 id="Add-PHP-Support-through-Dockerfile"><a href="#Add-PHP-Support-through-Dockerfile" class="headerlink" title="Add PHP Support through Dockerfile"></a>Add PHP Support through Dockerfile</h2><p>Open up the <code>Dockerfile</code> and add a second <code>RUN</code> command to install the other packages we want and enable some modules (yes, the list might be a tad excessive, but hey ..):</p>
<pre class=" language-makefile"><code class="language-makefile">RUN apt-get -y install libapache2-mod-php7.0 php7.0 php7.0-cli php-xdebug php7.0-mbstring sqlite3 php7.0-mysql php-imagick php-memcached php-pear curl imagemagick php7.0-dev php7.0-phpdbg php7.0-gd npm nodejs-legacy php7.0-json php7.0-curl php7.0-sqlite3 php7.0-intl apache2 vim git-core wget libsasl2-dev libssl-dev libsslcommon2-dev libcurl4-openssl-dev autoconf g++ make openssl libssl-dev libcurl4-openssl-dev pkg-config libsasl2-dev libpcre3-dev \
  &amp;&amp; a2enmod headers \
  &amp;&amp; a2enmod rewrite
</code></pre>
<h2 id="Rerunning-docker-compose"><a href="#Rerunning-docker-compose" class="headerlink" title="Rerunning docker-compose"></a>Rerunning docker-compose</h2><p>So, let’s see what effect this has, run from the command line:</p>
<pre class=" language-bash"><code class="language-bash">$ docker-compose down
$ docker-compose build
$ docker-compose up
</code></pre>
<p>The build step might take a while, so make sure to get some coffee while that runs, but don’t worry, build are incremental and cached, so you won’t have to wait for ages every time you want to get your environment up and running.</p>
<p>Once it’s all finished, visit <code>http://localhost</code></p>
<p>Huzar! We get the PHP information page.</p>
<h2 id="Add-a-database-container"><a href="#Add-a-database-container" class="headerlink" title="Add a database container"></a>Add a database container</h2><p>We want to run Laravel, which work with a database, so let’s get that set up.</p>
<p>Open up <code>docker-compose.yml</code> and add another service container:</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">...</span>
<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token punctuation">...</span>
  <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"./.data/db:/var/lib/mysql"</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> root
      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> laravel_ddb
      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> laravel
      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> laravel
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>
<span class="token punctuation">...</span>
</code></pre>
<p>This container will use another image. This time we won’t want to alter the container so the default <code>mysql:5.7</code> image will do. One thing to note is I added a <code>volumes</code> instruction. This will create a folder <code>.data</code> in our project folder which maps to the database container data folder. This makes sure we can persist data, even if we destroy the container and it allows us to commit the database to version control. Now, it’s up to you if you want to version control a local db or to .gitignore it, but having persisitent database data is a big win. Of course, you can just safely remove the <code>volumes</code> instruction and everything will be fine.</p>
<p>Right, that was easy .. just adding an extra container for extra functionality. And it is.</p>
<p>As part of good practice though, we should add a <code>depends_on</code> instruction to the <code>webserver</code> container, to make it explicit we want to use the db container,</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">...</span>
services
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token punctuation">...</span>
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db
<span class="token punctuation">...</span>
</code></pre>
<h2 id="Installing-Laravel"><a href="#Installing-Laravel" class="headerlink" title="Installing Laravel"></a>Installing Laravel</h2><p>Now let’s actually get our application up and running.<br>I won’t go over how to install Laravel, as the nice folks at the <a href="https://laravel.com/docs/5.3/installation" target="_blank" rel="external">Laravel Documention</a> do a good job doing that.</p>
<p>Just make sure you end up with the laravel project files and the Docker files in the same directory</p>
<p>Before, we just wanted the <code>htdocs</code> to be mapped, but with laravel we want our whole directory to be mapped to the container, so let’s change the <code>volumes</code> instruction. Additionally, Laravel wants the <code>public</code> directory to be the webroot. In order to do that we need to add an apache configuration file to our container.</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">'2'</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">webserver</span><span class="token punctuation">:</span>
    <span class="token key atrule">build</span><span class="token punctuation">:</span> .
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">'80:80'</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> ./<span class="token punctuation">:</span>/var/www/html
      <span class="token punctuation">-</span> ./apache.conf<span class="token punctuation">:</span>/etc/apache2/sites<span class="token punctuation">-</span>available/000<span class="token punctuation">-</span>default.conf
    <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> db

  <span class="token key atrule">db</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span class="token punctuation">:</span><span class="token number">5.7</span>
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"./.data/db:/var/lib/mysql"</span>
    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always
    <span class="token key atrule">environment</span><span class="token punctuation">:</span>
      <span class="token key atrule">MYSQL_ROOT_PASSWORD</span><span class="token punctuation">:</span> root
      <span class="token key atrule">MYSQL_DATABASE</span><span class="token punctuation">:</span> laravel_ddb
      <span class="token key atrule">MYSQL_USER</span><span class="token punctuation">:</span> laravel
      <span class="token key atrule">MYSQL_PASSWORD</span><span class="token punctuation">:</span> laravel
    <span class="token key atrule">ports</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> <span class="token string">"3306:3306"</span>
</code></pre>
<p>Notice we can add multiple volumes mappings. The second one maps the apache.conf file we will create in a second to the default website at the container (that way we can just re-use what’s already there and don’t have to create more server instructions).</p>
<p>The <code>apache.conf</code> will look like this:</p>
<pre class=" language-apacheconf"><code class="language-apacheconf"><span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>VirtualHost</span><span class="token directive-block-parameter attr-value"> *<span class="token punctuation">:</span>80</span><span class="token punctuation">></span></span>
  <span class="token directive-inline property">DocumentRoot</span> /var/www/html/public
  <span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;</span>Directory</span><span class="token directive-block-parameter attr-value"> /var/www/html/public</span><span class="token punctuation">></span></span>
    <span class="token directive-inline property">Options</span> Indexes FollowSymLinks MultiViews
    <span class="token directive-inline property">AllowOverride</span> All
    <span class="token directive-inline property">Order</span> <span class="token directive-inline property">allow</span>,deny
    <span class="token directive-inline property">allow</span> from all
  <span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>Directory</span><span class="token punctuation">></span></span>
<span class="token directive-block tag"><span class="token directive-block tag"><span class="token punctuation">&lt;/</span>VirtualHost</span><span class="token punctuation">></span></span>
</code></pre>
<p>And that’s it! Now we can run our <code>docker-compose</code> commands again:</p>
<pre class=" language-bash"><code class="language-bash">$ docker-compose down
$ docker-compose build
$ docker-compose up
</code></pre>
<p>And this time when we visit <code>http://localhost</code> we should see our fresh Laravel install!</p>
<p><img src="/images/reacts/huzar.gif" alt="Huzar"></p>
<h2 id="Caveat"><a href="#Caveat" class="headerlink" title="Caveat"></a>Caveat</h2><p>One thing to note is that these containers have their own spaces and thus IP adresses. In order for Laravel to connect to the database container it needs to know where it is. Luckily, we can just use the container name we used in the <code>docker-compose</code> file. So instead of connection to <code>127.0.0.1</code> we will connect to host <code>db</code>. This works, because our mysql container exposes the 3306 port and the webserver container <code>depends</code> on the mysql container.</p>
<h2 id="Summing-it-up"><a href="#Summing-it-up" class="headerlink" title="Summing it up"></a>Summing it up</h2><p>We now have a <code>docker-compose</code> file that instructs Docker to spin up 2 containers, one for our webserver (apache + php) and one for the database. Anyone who pull in the project and runs <code>docker-compose up</code> will have the exact same work environment since these files will be under version control.</p>
<p>If in the future a developer decides we need another module, package or server setting, he can just modify the Dockerfile or docker-compose settings, commit it, and it will be propagated to all other developers.</p>
<p>If you have any questions feel free to reach me at <a href="http://twitter.com/stefvdham" target="_blank" rel="external">@stefvdham</a> or in the comments below.</p>
<p>Happy coding!</p>
<hr/><ul class="tags"><li>Tags: </li><li class="post__tag__item"><a href="/tags/docker/" class="post__tag__link">docker</a></li><li class="post__tag__item"><a href="/tags/laravel/" class="post__tag__link">laravel</a></li></ul><a href="https://twitter.com/intent/tweet" class="twitter-share-button">Tweet</a><hr/><h2>Questions or comments?</h2><p>As always, if you have any questions or comments, you can find me on <a href="http://twitter.com/stefvdham"   target="_blank">Twitter</a>.</p><div class="prevnext"><a href="/getting-started-with-the-panresponder-in-react-native/" class="prevnext-prev"><p>← Prev</p></a><a href="/sorting-tags-in-jekyll/" class="prevnext-next"><p>Next →</p></a></div></article></main><footer><a href="/"><img src="http://mindthecode.com/images/mtc_inv_white.png" alt="Mindthecode" class="floating"></a><br><p>Made with ❤ and 🍺</p><p>Follow me on <a target="_blank" href="https://twitter.com/stefvdham">Twitter</a> or <a target="_blank" href="https://www.facebook.com/mindthecode/">Facebook</a></p><p>© Copyright 2011-2017</p></footer><script src="/js/main.js"></script><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&amp;serve=C6AILKT&amp;placement=mindthecode" id="_carbonads_js"></script></body></html>